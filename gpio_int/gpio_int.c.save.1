
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/gpio_keys.h>
#include <linux/of_platform.h>
#include <linux/of_gpio.h>
#include <linux/spinlock.h>
#include <linux/gpio.h>
#include <linux/interrupt.h> //--request_irq()
#include <linux/delay.h> //--msleep

#define CPU_PORT_CONTROL_BASE 0x01C20800
#define PG_EINT_CTL_REG (CPU_PORT_CONTROL_BASE + 0x230)

volatile unsigned long virt_addr,phys_addr;

static unsigned int gpio_int=203; //--linux num. for GP11
unsigned int gpio_beep=6;
unsigned int int_num=0;//--interrupter number
struct timespec tv;

static struct work_struct int_wq; //--work queue for INT handler low part

static void map_gpio_reg(void)
{
   phys_addr= PG_EINT_CTL_REG;
   virt_addr= (unsigned long)ioremap(phys_addr,4);
}

static void unmap_gpio_reg(void)
{
  iounmap((void *)virt_addr);
}

static void disable_gp11_int(void)
{
  volatile unsigned long *gp_conf_reg;
  uint32_t  conf_reg_val;

  gp_conf_reg=(unsigned long *)virt_addr+0; //--get pg_eint_ctl_reg register value
  conf_reg_val=ioread32(gp_conf_reg);
  //---disable gp11 int--
  conf_reg_val &= ~(1<<11);
  iowrite32(conf_reg_val,gp_conf_reg);
}

static void enable_gp11_int(void)
{
  volatile unsigned long *gp_conf_reg;
  uint32_t  conf_reg_val;

  gp_conf_reg=(unsigned long *)virt_addr+0; //--get pg_eint_ctl_reg register value
  conf_reg_val=ioread32(gp_conf_reg);
  //---enable gp11 int--
  conf_reg_val |= (1<<11);
  iowrite32(conf_reg_val,gp_conf_reg);
}


static void get_gp_config(void)
{
  volatile unsigned long *gp_conf_reg;
  uint32_t  conf_reg_val;

  gp_conf_reg=(unsigned long *)virt_addr+0; //--get pg_eint_ctl_reg register value
  conf_reg_val=ioread32(gp_conf_reg);

  printk("----- PG_EINT_CTL_REG: 0x%04x -----\n",conf_reg_val);

}

static void enable_int_wq(struct work_struct *data)
{
   printk(KERN_INFO"Entering work_queue and start msleep....\n");
   msleep(500);
   gpio_set_value(gpio_beep,0); //--stop beeping ... 

   printk(KERN_INFO"Re-enable irq now....\n");

   enable_irq(int_num);
   enable_gp11_int();
   get_gp_config();
}

static irqreturn_t int_handler(int irq, void *dev_id)
{
   disable_gp11_int();
   get_gp_config();
   disable_irq_nosync(int_num); //--!!!Must NOT use disable_irq() anyway,it's cause deadloop and will crash the kernel
   //---!!! to stop HW interrupt also

   printk(KERN_INFO "------ gpio_to_irq(PG11) triggered! -----\n");
   printk(KERN_INFO "Disable irq ...\n");
 
   gpio_set_value(gpio_beep,1); //--start to beep... 
   //----- irq handler low part -------
   schedule_work(&int_wq);

   return IRQ_HANDLED;
}


static int register_gpio_irq(void)
{
   int int_result=0;
   int_result=request_irq(int_num,int_handler,IRQF_TRIGGER_RISING,"GPIO_INT_Midas",(void *)&gpio_int);
   if(int_result != 0)
   {
	printk(KERN_EMERG "--- GPIO request irq failed! ---\n");
   }

   return int_result;
}

static int __init gpio_int_init(void)
{
   int ret=-1;

   printk("------ Start init gpio_int -----\n");

   map_gpio_reg();
   get_gp_config(); 

   gpio_direction_output(gpio_beep,0);
   if(gpio_is_valid(gpio_beep) == 0)
   {
	printk("gpio_beep is valid!\n");
	gpio_set_value(gpio_beep,0);
   }
   else
	printk("gpio_beep is NOT valid!\n");

   gpio_direction_input(gpio_int); //-set gpio direction
   if(gpio_is_valid(gpio_int) == 0)
   {
	printk("gpio_int is valid!\n");
	gpio_set_value(gpio_int,0);
   }
   else
	printk("gpio_int is NOT valid!\n");

//   gpio_set_value(gpio_int,0);

   int_num=gpio_to_irq(gpio_int);
   if(int_num>0)
	printk(KERN_INFO "------ gpio_to_irq(PG11):%d -----\n",int_num);
   else
	return -1;

   ret=register_gpio_irq();
   if(ret!= 0)
   {
	printk(KERN_EMERG "----- register_gpio_irq() failed! ----\n");
        return -1;
   }
   else
	//---init wor-queue for irq-handler low part
        INIT_WORK(&int_wq,enable_int_wq);

	get_gp_config();

	return 0;
}

static void __exit gpio_int_exit(void)
{

  if(int_num > 0) 
  	free_irq(int_num,(void *)&gpio_int); //---!!! void *dev_id MUST be presented,eve no IRQF_SHARED flag in request_irq(xx)

  unmap_gpio_reg();

  printk("------ gpio interrupt test exit -----\n");

}

module_init(gpio_int_init);
module_exit(gpio_int_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Linux");
MODULE_DESCRIPTION("gpio-int-test");

